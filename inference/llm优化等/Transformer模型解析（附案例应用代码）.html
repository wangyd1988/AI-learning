<!DOCTYPE html>
<html lang="zh-CN">
 <head>
  <meta charset="utf-8"/>
  <link href="https://blog.csdn.net/LIUMAO99/article/details/141183589" rel="canonical"/>
  <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
  <meta content="webkit" name="renderer">
   <meta content="webkit" name="force-rendering">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
    <meta content="always" name="referrer"/>
    <meta content="no-siteapp" http-equiv="Cache-Control">
     <link href="#" media="handheld" rel="alternate"/>
     <meta content="pc" name="applicable-device"/>
     <link href="https://g.csdnimg.cn/static/logo/favicon32.ico" rel="shortcut icon" type="image/x-icon"/>
     <title>
      Transformer模型解析（附案例应用代码）-CSDN博客
     </title>
     <meta content="transformer模型" name="keywords"/>
     <meta content='{"autorun":true,"install":true,"keyword":"transformer模型详解"}' name="csdn-baidu-search"/>
     <meta content="文章浏览阅读6.6k次，点赞11次，收藏54次。自注意力机制是Transformer模型的核心，它允许模型在编码每个单词时同时关注序列中的其他单词，从而捕捉到单词之间的依赖关系。位置编码的生成使用了正弦和余弦函数的不同频率，以确保编码在不同维度上具有不同的模式，从而使模型能够区分不同位置的单词。这样，每个头可以学习到序列的不同方面，最终的输出是所有头输出的连接和线性变换的结果。通过结合残差连接和层归一化，Transformer模型能够有效地训练深层网络，同时保持稳定的梯度流动和良好的特征分布，这对于理解和生成复杂的序列数据至关重要。_transformer模型" name="description"/>
     <link href="https://csdnimg.cn/release/blogv2/dist/pc/css/detail_enter-af0ead44cd.min.css" rel="stylesheet" type="text/css"/>
     <link href="https://csdnimg.cn/release/blogv2/dist/pc/themesSkin/skin-whitemove/skin-whitemove-2af9149bdc.min.css" rel="stylesheet" type="text/css"/>
     <meta content='{"type":"0","fixModel":"1"}' name="toolbar"/>
     <link href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css" rel="stylesheet" type="text/css"/>
     <style>
      .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
     </style>
    </meta>
   </meta>
  </meta>
  <style type="text/css">
   * { user-select: text; } pre{max-height: none!important; overflow-y: hidden;}
  </style>
 </head>
 <body class="nodata" style="">
  <link href="https://csdnimg.cn/release/blogv2/dist/pc/css/blog_code-01256533b5.min.css" rel="stylesheet"/>
  <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/chart-3456820cac.css" rel="stylesheet">
   <link href="https://g.csdnimg.cn/lib/swiper/6.0.4/css/swiper.css" rel="stylesheet">
    <div class="main_father clearfix d-flex justify-content-center mainfather-concision" style="height:100%;">
     <div class="container clearfix container-concision" id="mainBox">
      <main>
       <div class="blog-content-box">
        <div class="article-header-box">
         <div class="article-header">
          <div class="article-title-box">
           <h1 class="title-article" id="articleContentId">
            Transformer模型解析（附案例应用代码）
           </h1>
          </div>
          <div class="article-info-box">
           <div class="article-bar-top">
            <img alt="" class="article-type-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"/>
            <div class="bar-content">
             <a class="article-vip-box" data-report-click='{"spm":"3001.10404"}' data-report-query="spm=3001.10404" data-report-view='{"spm":"3001.10404"}' href="https://mall.csdn.net/vip" target="_blank">
              <img alt="" class="article-vip-img-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/identityVipNew.png"/>
             </a>
             <a class="follow-nickName" href="https://blog.csdn.net/LIUMAO99" rel="noopener" target="_blank" title="CCC：CarCrazeCurator">
              CCC：CarCrazeCurator
             </a>
             <img alt="" class="article-time-img article-heard-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCurrentTime2.png"/>
             <span class="time">
              于 2024-08-14 13:59:47 发布
             </span>
             <div class="read-count-box">
              <img alt="" class="article-read-img article-heard-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png"/>
              <span class="read-count">
               阅读量6.6k
              </span>
              <a class="un-collection" data-report-click='{"mod":"popu_823","spm":"1001.2101.3001.4232","ab":"new"}' id="blog_detail_zk_collection">
               <img alt="" class="article-collect-img article-heard-img un-collect-status isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png" style="display:inline-block"/>
               <img alt="" class="article-collect-img article-heard-img collect-status isactive" src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png" style="display:none"/>
               <span class="name">
                收藏
               </span>
               <span class="get-collection">
                54
               </span>
              </a>
              <div class="read-count-box is-like">
               <img alt="" class="article-read-img article-heard-img" id="is-like-imgactive-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png" style="display:none"/>
               <img alt="" class="article-read-img article-heard-img" id="is-like-img-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png" style="display:block"/>
               <span class="read-count" id="blog-digg-num">
                点赞数
                            11
               </span>
              </div>
             </div>
            </div>
           </div>
           <div class="blog-tags-box">
            <div class="tags-box artic-tag-box">
             <span class="label">
              文章标签：
             </span>
             <a class="tag-link" data-report-click='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"transformer","ab":"new","extra":"{\"searchword\":\"transformer\"}"}' data-report-query="spm=1001.2101.3001.4223" data-report-view='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"transformer","ab":"new","extra":"{\"searchword\":\"transformer\"}"}' href="https://so.csdn.net/so/search/s.do?q=transformer&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" rel="noopener" target="_blank">
              transformer
             </a>
             <a class="tag-link" data-report-click='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"深度学习","ab":"new","extra":"{\"searchword\":\"深度学习\"}"}' data-report-query="spm=1001.2101.3001.4223" data-report-view='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"深度学习","ab":"new","extra":"{\"searchword\":\"深度学习\"}"}' href="https://so.csdn.net/so/search/s.do?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" rel="noopener" target="_blank">
              深度学习
             </a>
             <a class="tag-link" data-report-click='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"人工智能","ab":"new","extra":"{\"searchword\":\"人工智能\"}"}' data-report-query="spm=1001.2101.3001.4223" data-report-view='{"mod":"popu_626","spm":"1001.2101.3001.4223","strategy":"人工智能","ab":"new","extra":"{\"searchword\":\"人工智能\"}"}' href="https://so.csdn.net/so/search/s.do?q=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" rel="noopener" target="_blank">
              人工智能
             </a>
            </div>
           </div>
           <div class="slide-content-box">
            <div class="article-copyright">
             <div class="creativecommons">
              版权声明：本文为博主原创文章，遵循
              <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="noopener" target="_blank">
               CC 4.0 BY-SA
              </a>
              版权协议，转载请附上原文出处链接和本声明。
             </div>
             <div class="article-source-link">
              本文链接：
              <a href="https://blog.csdn.net/LIUMAO99/article/details/141183589" target="_blank">
               https://blog.csdn.net/LIUMAO99/article/details/141183589
              </a>
             </div>
            </div>
           </div>
           <div class="operating">
            <a class="href-article-edit slide-toggle">
             版权
            </a>
           </div>
          </div>
         </div>
        </div>
        <div id="blogHuaweiyunAdvert">
        </div>
        <article class="baidu_pl">
         <div class="article_content clearfix" id="article_content">
          <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css" rel="stylesheet"/>
          <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-704d5b9767.css" rel="stylesheet"/>
          <div class="htmledit_views" id="content_views">
           <h2 style="background-color:transparent;">
            <span style="color:#333333;">
             1. Transformer模型概述
            </span>
           </h2>
           <p>
            <span style="color:#333333;">
             Transformer是一种基于自注意力机制的神经网络架构，由Vaswani等人在2017年的论文《Attention Is All You Need》中首次提出。这种模型最初是为了改善机器翻译任务而设计的，其创新之处在于摒弃了传统的循环神经网络（RNN）结构，转而使用注意力机制来处理序列数据。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <img alt="" height="832" src="https://i-blog.csdnimg.cn/direct/4c533994767248799e744870bb9981dd.png" width="1200"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             Transformer模型的核心优势在于其能够并行处理序列中的所有元素，这极大地提高了模型的训练效率。此外，由于其优秀的泛化能力，Transformer模型很快在自然语言处理（NLP）领域的其他任务中展现出了卓越的性能，包括文本摘要、情感分析、问答系统等。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             Transformer模型的关键在于以下几个核心特性：
            </span>
           </p>
           <ul>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                自注意力机制（Self-Attention）
               </strong>
               ：允许模型在编码或解码时关注序列中的不同部分，而不是依赖于序列中元素的固定顺序。这种机制使得模型能够捕捉长距离依赖关系，并且提高了计算效率。
              </span>
             </p>
            </li>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                多头注意力（Multi-Head Attention）
               </strong>
               ：通过并行地执行多个注意力函数，模型可以从不同的表示子空间中学习信息，这增强了模型捕获信息的能力。
              </span>
             </p>
            </li>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                位置编码（Positional Encoding）
               </strong>
               ：由于Transformer模型缺乏RNNs的固有序列处理能力，位置编码被添加到输入嵌入中，以提供序列中单词的位置信息。
              </span>
             </p>
            </li>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                残差连接和层归一化（Residual Connections and Layer Normalization）
               </strong>
               ：这些技术有助于避免深层网络训练中的梯度消失问题，并使得模型可以有效地训练更深的网络。
              </span>
             </p>
            </li>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                可扩展性
               </strong>
               ：Transformer模型的设计允许其容易地扩展到更大的模型尺寸和更复杂的任务中。
              </span>
             </p>
            </li>
            <li>
             <p>
              <span style="color:#333333;">
               <strong>
                泛化能力
               </strong>
               ：Transformer模型不仅在NLP领域表现出色，还被扩展应用到图像处理、语音识别等其他领域，显示出良好的跨领域泛化能力。
              </span>
             </p>
            </li>
           </ul>
           <p>
            <span style="color:#333333;">
             这些特性共同构成了Transformer模型的基础，使其成为当前深度学习中最重要的模型之一。随着研究的深入，Transformer模型及其变体在各种任务中都取得了显著的成果。
            </span>
           </p>
           <h2>
            <span style="color:#333333;">
             2. Transformer模型结构
            </span>
           </h2>
           <h3>
            <span style="color:#333333;">
             2.1 Encoder架构
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             Transformer模型的Encoder部分由多个相同的层（通常是6层）堆叠而成，每层主要由两部分组成：多头自注意力机制（Multi-Head Self-Attention）和位置前馈全连接网络（Position-wise Fully Connected Feed-Forward Network）。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              多头自注意力机制
             </strong>
             ：该机制允许模型在编码单词时，不仅关注该单词本身，还能捕捉到句子中其他单词的信息。这种机制通过计算单词间的注意力分数实现，公式如下：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Attention(Q,K,V)=softmax(\frac{QK^{T}}{\sqrt{d_{k}}})V" class="mathcode" src="https://latex.csdn.net/eq?Attention%28Q%2CK%2CV%29%3Dsoftmax%28%5Cfrac%7BQK%5E%7BT%7D%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D%29V"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中，
             <img alt="Q" class="mathcode" src="https://latex.csdn.net/eq?Q">
              、
              <img alt="K" class="mathcode" src="https://latex.csdn.net/eq?K">
               、
               <img alt="V" class="mathcode" src="https://latex.csdn.net/eq?V">
                分别代表查询（Query）、键（Key）、值（Value）矩阵，
                <img alt="d_{k}" class="mathcode" src="https://latex.csdn.net/eq?d_%7Bk%7D">
                 ​ 是键向量的维度，
                 <img alt="\sqrt{d_{k}}" class="mathcode" src="https://latex.csdn.net/eq?%5Csqrt%7Bd_%7Bk%7D%7D">
                  用于缩放点积以防止梯度消失问题。
                 </img>
                </img>
               </img>
              </img>
             </img>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              位置前馈全连接网络
             </strong>
             ：在自注意力层之后，每个位置的输出会通过一个前馈网络进行进一步的非线性变换，公式为：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="FFN(x)=max\left ( 0,xW_{1}+b_{1} \right )W_{2}+b_{2}" class="mathcode" src="https://latex.csdn.net/eq?FFN%28x%29%3Dmax%5Cleft%20%28%200%2CxW_%7B1%7D&amp;plus;b_%7B1%7D%20%5Cright%20%29W_%7B2%7D&amp;plus;b_%7B2%7D"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             这里，
             <img alt="W_{1}" class="mathcode" src="https://latex.csdn.net/eq?W_%7B1%7D"/>
             、
             <img alt="W_{2}" class="mathcode" src="https://latex.csdn.net/eq?W_%7B2%7D"/>
             和
             <img alt="b_{1}" class="mathcode" src="https://latex.csdn.net/eq?b_%7B1%7D"/>
             ​、
             <img alt="b_{2}" class="mathcode" src="https://latex.csdn.net/eq?b_%7B2%7D"/>
             ​ 分别是前馈网络的权重和偏置。
            </span>
           </p>
           <h3>
            <span style="color:#333333;">
             2.2 Decoder架构
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             Decoder同样由多个相同的层堆叠而成，每层包括三个主要部分：遮蔽多头自注意力、Encoder-Decoder注意力和位置前馈全连接网络。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              遮蔽多头自注意力
             </strong>
             ：与Encoder中的自注意力类似，但加入了遮蔽（Mask）机制，确保在预测下一个词时，只能看到已经生成的词，避免信息泄露。公式与Encoder中的自注意力相同。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              Encoder-Decoder注意力
             </strong>
             ：Decoder层通过这一层关注Encoder的输出，帮助模型在生成翻译或回应时，关注输入序列中的关键部分。公式为：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Attention(Q{}',K,V)=softmax(\frac{Q{}'K^{T}}{\sqrt{d_{k}}})V" class="mathcode" src="https://latex.csdn.net/eq?Attention%28Q%7B%7D%27%2CK%2CV%29%3Dsoftmax%28%5Cfrac%7BQ%7B%7D%27K%5E%7BT%7D%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D%29V"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中，
             <img alt="Q{}'" class="mathcode" src="https://latex.csdn.net/eq?Q%7B%7D%27"/>
             是来自Decoder上一层的查询矩阵。
            </span>
           </p>
           <h3>
            <span style="color:#333333;">
             2.3 编码器与解码器交互
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             编码器与解码器之间的交互主要通过以下方式实现：
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              残差连接
             </strong>
             ：在每个子层（自注意力或前馈网络）的输出上，添加了输入的副本，然后进行层归一化（Layer Normalization）。残差连接的公式为：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Output=LayerNorm(x+Sublayer(x))" class="mathcode" src="https://latex.csdn.net/eq?Output%3DLayerNorm%28x&amp;plus;Sublayer%28x%29%29"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中，
             <img alt="x" class="mathcode" src="https://latex.csdn.net/eq?x"/>
             是子层的输入，
             <img alt="Sublayer(x)" class="mathcode" src="https://latex.csdn.net/eq?Sublayer%28x%29"/>
             是子层的输出。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             <strong>
              层归一化
             </strong>
             ：在残差连接之后，使用层归一化处理输出，以稳定训练过程，加速收敛速度。归一化的公式为：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="LayerNorm(x)=\frac{x-\mu }{\sigma }" class="mathcode" src="https://latex.csdn.net/eq?LayerNorm%28x%29%3D%5Cfrac%7Bx-%5Cmu%20%7D%7B%5Csigma%20%7D"/>
             ​
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             这里，
             <img alt="\mu" class="mathcode" src="https://latex.csdn.net/eq?%5Cmu"/>
             和
             <img alt="\sigma" class="mathcode" src="https://latex.csdn.net/eq?%5Csigma"/>
             分别是
             <img alt="x" class="mathcode" src="https://latex.csdn.net/eq?x"/>
             的均值和标准差。
            </span>
           </p>
           <h2>
            <span style="color:#333333;">
             3. 自注意力机制（Self-Attention）
            </span>
           </h2>
           <h3>
            <span style="color:#333333;">
             3.1 基本原理
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             自注意力机制是Transformer模型的核心，它允许模型在编码每个单词时同时关注序列中的其他单词，从而捕捉到单词之间的依赖关系。这种机制的关键在于计算输入序列中每个单词对其他单词的注意力分数，并根据这些分数进行加权求和。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             在自注意力的计算过程中，首先将输入序列中的每个单词映射为三个向量：查询（Query, Q）、键（Key, K）和值（Value, V）。这些向量通过与不同的权重矩阵相乘得到：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Q=X\cdot W^{Q}" class="mathcode" src="https://latex.csdn.net/eq?Q%3DX%5Ccdot%20W%5E%7BQ%7D"/>
             ,
             <img alt="K=X\cdot W^{K}" class="mathcode" src="https://latex.csdn.net/eq?K%3DX%5Ccdot%20W%5E%7BK%7D"/>
             ,
             <img alt="V=X\cdot W^{V}" class="mathcode" src="https://latex.csdn.net/eq?V%3DX%5Ccdot%20W%5E%7BV%7D"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中，
             <img alt="X" class="mathcode" src="https://latex.csdn.net/eq?X"/>
             是输入序列的嵌入表示，
             <img alt="W^{Q}" class="mathcode" src="https://latex.csdn.net/eq?W%5E%7BQ%7D"/>
             ,
             <img alt="W^{K}" class="mathcode" src="https://latex.csdn.net/eq?W%5E%7BK%7D"/>
             ,
             <img alt="W^{V}" class="mathcode" src="https://latex.csdn.net/eq?W%5E%7BV%7D"/>
             是模型参数。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             接下来，计算注意力分数，这通常通过查询向量与所有键向量的点积来实现，然后应用一个缩放因子（通常是键向量维度的平方根）以避免梯度消失问题：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Attention Score=\frac{QK^{T}}{\sqrt{d_{k}}}" class="mathcode" src="https://latex.csdn.net/eq?Attention%20Score%3D%5Cfrac%7BQK%5E%7BT%7D%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             随后，通过Softmax函数对注意力分数进行归一化处理，确保所有分数的和为1：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Attention Weights=Softmax(Attention Score)" class="mathcode" src="https://latex.csdn.net/eq?Attention%20Weights%3DSoftmax%28Attention%20Score%29"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             最后，将归一化的注意力权重与值向量相乘，并求和，得到最终的输出：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="Output=\sum_{i}^{}Attention Weights_{i}\cdot V_{i}" class="mathcode" src="https://latex.csdn.net/eq?Output%3D%5Csum_%7Bi%7D%5E%7B%7DAttention%20Weights_%7Bi%7D%5Ccdot%20V_%7Bi%7D"/>
            </span>
           </p>
           <h3>
            <span style="color:#333333;">
             3.2 多头注意力（Multi-Head Attention）
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             多头注意力是自注意力的一个扩展，它允许模型同时从不同的表示子空间捕捉信息。这一机制通过将输入序列通过多个注意力头并行处理，每个头使用不同的参数集来实现。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             具体来说，多头注意力首先将输入序列的嵌入表示分割成多个头，每个头独立地执行自注意力计算：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="MultiHead(Q,K,V)=Concat(head1,\cdots ,headh)\cdot W^{O}" class="mathcode" src="https://latex.csdn.net/eq?MultiHead%28Q%2CK%2CV%29%3DConcat%28head1%2C%5Ccdots%20%2Cheadh%29%5Ccdot%20W%5E%7BO%7D"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中，
             <img alt="head_{i}" class="mathcode" src="https://latex.csdn.net/eq?head_%7Bi%7D"/>
             ​ 代表第
             <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
             个注意力头的输出，
             <img alt="W^{O}" class="mathcode" src="https://latex.csdn.net/eq?W%5E%7BO%7D"/>
             是最终的输出权重矩阵，用于将所有头的输出合并回原始维度。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             每个头的自注意力计算遵循与3.1节描述的相同的步骤，但使用不同的权重矩阵。这样，每个头可以学习到序列的不同方面，最终的输出是所有头输出的连接和线性变换的结果。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             多头注意力的优势在于它能够并行处理多个子任务，并且通过合并多个头的结果，模型能够获得更全面的序列表示。这种机制在处理长距离依赖关系时尤其有效，因为它允许模型在不同的表示子空间中同时捕捉局部和全局的上下文信息。
            </span>
           </p>
           <h2>
            <span style="color:#333333;">
             4. 位置编码（Positional Encoding）
            </span>
           </h2>
           <p>
            <span style="color:#333333;">
             位置编码是Transformer模型中一个关键的组成部分，它使得模型能够捕捉序列中单词的相对位置信息。
            </span>
           </p>
           <h3>
            <span style="color:#333333;">
             4.1 重要性
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             在自然语言处理中，单词的顺序对于理解句子的意义至关重要。然而，Transformer模型中的自注意力机制本身并不包含处理序列顺序的能力。因此，位置编码的引入成为了解决这一问题的关键。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             位置编码允许模型在处理单词时，同时考虑到它们在句子中的位置，从而增强了模型对序列数据的理解能力。这对于诸如机器翻译、文本摘要等任务来说至关重要，因为这些任务都需要模型能够准确理解单词之间的顺序关系。
            </span>
           </p>
           <h3>
            <span style="color:#333333;">
             4.2 计算方法
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             位置编码的计算方法在原始的Transformer论文中被详细描述。以下是其计算公式的简化说明：
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             给定一个位置pp和一个维度ii，位置编码的值可以通过以下公式计算：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="PE_{(pos,2i))}=sin(\frac{pos}{10000^{2i/d_{model}}})" class="mathcode" src="https://latex.csdn.net/eq?PE_%7B%28pos%2C2i%29%29%7D%3Dsin%28%5Cfrac%7Bpos%7D%7B10000%5E%7B2i/d_%7Bmodel%7D%7D%7D%29"/>
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="PE_{(pos,2i+1))}=cos(\frac{pos}{10000^{2i/d_{model}}})" class="mathcode" src="https://latex.csdn.net/eq?PE_%7B%28pos%2C2i&amp;plus;1%29%29%7D%3Dcos%28%5Cfrac%7Bpos%7D%7B10000%5E%7B2i/d_%7Bmodel%7D%7D%7D%29"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             这里，
             <img alt="pos" class="mathcode" src="https://latex.csdn.net/eq?pos"/>
             表示单词在序列中的位置，
             <img alt="i" class="mathcode" src="https://latex.csdn.net/eq?i"/>
             表示维度索引，
             <img alt="d_{model}" class="mathcode" src="https://latex.csdn.net/eq?d_%7Bmodel%7D"/>
             是模型的维度大小。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             位置编码的生成使用了正弦和余弦函数的不同频率，以确保编码在不同维度上具有不同的模式，从而使模型能够区分不同位置的单词。每个位置的编码向量由上述正弦和余弦函数的值构成，这些向量随后会被添加到词嵌入向量中，为模型提供位置信息。
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             这种编码方式的优势在于它不需要学习，可以应用于任意长度的序列，并且能够保持相对位置的不变性，这对于模型处理长距离依赖关系特别有用。通过这种方式，Transformer模型能够在不考虑单词实际顺序的情况下，有效地捕捉序列数据中的顺序信息。
            </span>
           </p>
           <h2>
            <span style="color:#333333;">
             5. 前馈网络（Feed Forward Neural Network）
            </span>
           </h2>
           <h3>
            <span style="color:#333333;">
             5.1 结构与功能
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             前馈神经网络（Feed Forward Neural Network, FFNN）是Transformer架构中的重要组成部分，负责对自注意力层的输出进行进一步的非线性变换和特征提取。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             结构
            </span>
           </h4>
           <p>
            <span style="color:#333333;">
             FFNN通常由若干层全连接的神经网络组成，每一层都包含多个神经元。在Transformer中，FFNN一般由两个线性变换组成，中间夹着一个非线性激活函数，如ReLU。
            </span>
           </p>
           <ul>
            <li>
             <span style="color:#333333;">
              <strong>
               输入层
              </strong>
              ：接收来自自注意力层的输出，这些输出是序列中每个位置的向量表示。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               隐藏层
              </strong>
              ：至少一个隐藏层，可以有多个神经元，进行线性变换，增加模型的非线性表达能力。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               激活函数
              </strong>
              ：通常使用ReLU（Rectified Linear Unit）作为激活函数，它能够引入非线性，帮助模型学习复杂的特征。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               输出层
              </strong>
              ：将隐藏层的信息进行线性变换，输出到下一层或其他组件。
             </span>
            </li>
           </ul>
           <h4>
            <span style="color:#333333;">
             功能
            </span>
           </h4>
           <p>
            <span style="color:#333333;">
             FFNN在Transformer中的功能主要包括：
            </span>
           </p>
           <ul>
            <li>
             <span style="color:#333333;">
              <strong>
               特征提取
              </strong>
              ：通过对输入数据进行高维空间映射，FFNN能够提取更深层次的特征表示。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               非线性变换
              </strong>
              ：引入非线性激活函数，使得模型能够捕捉和学习数据中的复杂模式和关系。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               并行处理
              </strong>
              ：由于FFNN中的每一层都是独立同分布的，可以并行处理输入序列中的每个位置，提高计算效率。
             </span>
            </li>
           </ul>
           <h4>
            <span style="color:#333333;">
             公式说明
            </span>
           </h4>
           <p>
            <span style="color:#333333;">
             在数学上，FFNN的前向传播可以通过以下公式表示：
            </span>
           </p>
           <p style="text-align:center;">
            <span style="color:#333333;">
             <img alt="y=f(W_{2}\cdot \sigma (W_{1}\cdot x+b_{1})+b_{2})" class="mathcode" src="https://latex.csdn.net/eq?y%3Df%28W_%7B2%7D%5Ccdot%20%5Csigma%20%28W_%7B1%7D%5Ccdot%20x&amp;plus;b_%7B1%7D%29&amp;plus;b_%7B2%7D%29"/>
            </span>
           </p>
           <p>
            <span style="color:#333333;">
             其中：
            </span>
           </p>
           <ul>
            <li>
             <span style="color:#333333;">
              <img alt="x" class="mathcode" src="https://latex.csdn.net/eq?x"/>
              是输入向量。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <img alt="W_{1}" class="mathcode" src="https://latex.csdn.net/eq?W_%7B1%7D"/>
              ​ 和
              <img alt="W_{2}" class="mathcode" src="https://latex.csdn.net/eq?W_%7B2%7D"/>
              是权重矩阵。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <img alt="b_{1}" class="mathcode" src="https://latex.csdn.net/eq?b_%7B1%7D"/>
              ​ 和
              <img alt="b_{2}" class="mathcode" src="https://latex.csdn.net/eq?b_%7B2%7D"/>
              ​ 是偏置项。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <img alt="\sigma" class="mathcode" src="https://latex.csdn.net/eq?%5Csigma"/>
              是激活函数，如ReLU：
              <img alt="\sigma (x)=max(0,x)" class="mathcode" src="https://latex.csdn.net/eq?%5Csigma%20%28x%29%3Dmax%280%2Cx%29"/>
              。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <img alt="f" class="mathcode" src="https://latex.csdn.net/eq?f"/>
              通常是一个线性函数，即
              <img alt="f(x)=x" class="mathcode" src="https://latex.csdn.net/eq?f%28x%29%3Dx"/>
              。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <img alt="y" class="mathcode" src="https://latex.csdn.net/eq?y"/>
              是FFNN的输出向量。
             </span>
            </li>
           </ul>
           <p>
            <span style="color:#333333;">
             这个公式展示了输入向量如何通过一系列线性和非线性操作转换成输出向量。通过这种方式，FFNN能够学习输入数据的复杂映射关系，为下游任务提供更丰富的特征表示。
            </span>
           </p>
           <h2 style="background-color:transparent;">
            <span style="color:#333333;">
             6. 残差连接与层归一化
            </span>
           </h2>
           <h3>
            <span style="color:#333333;">
             6.1 残差连接原理
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             残差连接是Transformer模型中的一项关键技术，它允许网络中的信号直接跨越多个层进行传递。这种设计有效缓解了深层网络训练中的梯度消失问题，增强了模型的学习能力。
            </span>
           </p>
           <ul>
            <li>
             <span style="color:#333333;">
              <strong>
               信号传递
              </strong>
              ：在标准的神经网络层中，输入通过一系列的操作后得到输出，而残差连接则将输入直接添加到这些操作的输出上。具体来说，如果一个层的输入为
              <img alt="x" class="mathcode" src="https://latex.csdn.net/eq?x"/>
              ，则该层的输出
              <img alt="y" class="mathcode" src="https://latex.csdn.net/eq?y"/>
              会与
              <img alt="x" class="mathcode" src="https://latex.csdn.net/eq?x"/>
              相加，即
              <img alt="y+x" class="mathcode" src="https://latex.csdn.net/eq?y&amp;plus;x"/>
              。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               梯度流动
              </strong>
              ：残差连接通过跳跃连接允许梯度在网络中的直接传播，这有助于在反向传播过程中梯度能够更有效地流向前面的层，从而减少了深层网络训练的不稳定性。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               实现公式
              </strong>
              ：在数学上，残差连接可以表示为
              <img alt="y=F(x)+x" class="mathcode" src="https://latex.csdn.net/eq?y%3DF%28x%29&amp;plus;x"/>
              ，其中
              <img alt="F(x)" class="mathcode" src="https://latex.csdn.net/eq?F%28x%29"/>
              是经过某一层处理后的输出。
             </span>
            </li>
           </ul>
           <h3>
            <span style="color:#333333;">
             6.2 层归一化作用
            </span>
           </h3>
           <p>
            <span style="color:#333333;">
             层归一化（Layer Normalization）是另一种用于稳定深层网络训练的技术，它通过对每个样本的每个特征进行归一化来实现。
            </span>
           </p>
           <ul>
            <li>
             <span style="color:#333333;">
              <strong>
               归一化过程
              </strong>
              ：层归一化会计算当前层输入的均值和标准差，并使用这些统计量来调整每个特征的尺度，使其具有稳定的分布。这有助于防止特征间的相互干扰，提高模型的泛化能力。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               数学表达
              </strong>
              ：层归一化的公式为
              <img alt="LN(x)=\gamma \cdot \frac{x-\mu }{\sigma }+\beta" class="mathcode" src="https://latex.csdn.net/eq?LN%28x%29%3D%5Cgamma%20%5Ccdot%20%5Cfrac%7Bx-%5Cmu%20%7D%7B%5Csigma%20%7D&amp;plus;%5Cbeta"/>
              ，其中
              <img alt="\mu" class="mathcode" src="https://latex.csdn.net/eq?%5Cmu"/>
              是特征的均值，
              <img alt="\sigma" class="mathcode" src="https://latex.csdn.net/eq?%5Csigma"/>
              是标准差，
              <img alt="\gamma" class="mathcode" src="https://latex.csdn.net/eq?%5Cgamma"/>
              和
              <img alt="\beta" class="mathcode" src="https://latex.csdn.net/eq?%5Cbeta"/>
              是可学习的参数，用于对归一化后的数据进行缩放和平移。
             </span>
            </li>
            <li>
             <span style="color:#333333;">
              <strong>
               与批归一化的区别
              </strong>
              ：与批归一化（Batch Normalization）不同，层归一化是在单个样本的特征上进行的，而不是在整个批次上。这使得它更适合处理如自然语言处理中的序列数据，这些数据的长度可能会变化。
             </span>
            </li>
           </ul>
           <p>
            <span style="color:#333333;">
             通过结合残差连接和层归一化，Transformer模型能够有效地训练深层网络，同时保持稳定的梯度流动和良好的特征分布，这对于理解和生成复杂的序列数据至关重要。
            </span>
           </p>
           <h2 style="background-color:transparent;">
            <span style="color:#333333;">
             7.Transformer案例应用
            </span>
           </h2>
           <h4>
            <span style="color:#333333;">
             引入必要的库
            </span>
           </h4>
           <pre><code class="language-python">import torch              # 导入PyTorch库，用于后续的张量操作和神经网络构建
import torch.nn as nn     # 导入PyTorch神经网络模块，用于构建网络层
import torch.nn.functional as F  # 导入PyTorch的函数式接口，用于一些常用的激活函数和操作</code></pre>
           <p>
            <span style="color:#333333;">
             这部分代码引入了PyTorch深度学习框架，它是目前最广泛使用的库之一，用于构建和训练神经网络模型。
             <code>
              torch
             </code>
             包含了基础的张量操作，
             <code>
              torch.nn
             </code>
             用于构建神经网络层，而
             <code>
              torch.nn.functional
             </code>
             提供了一些函数式的接口，用于实现激活函数等操作。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             定义Transformer编码器层
            </span>
           </h4>
           <pre><code class="language-cpp">class TransformerEncoderLayer(nn.Module):
    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1):
        super(TransformerEncoderLayer, self).__init__()  # 继承nn.Module的构造函数，是所有网络模块的基类
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)  # 初始化多头自注意力机制层
        self.linear1 = nn.Linear(d_model, dim_feedforward)  # 初始化第一个线性变换层，用于前馈网络的第一部分
        self.linear2 = nn.Linear(dim_feedforward, d_model)  # 初始化第二个线性变换层，用于前馈网络的第二部分
        self.dropout = nn.Dropout(dropout)  # 初始化dropout层，用于正则化以防止过拟合
        self.activation = F.relu  # 定义激活函数为ReLU</code></pre>
           <p>
            <span style="color:#333333;">
             Transformer编码器层是Transformer模型的核心组成部分，负责处理输入序列并提取特征。这个层包含了多头自注意力机制，它允许模型在编码时同时关注序列中的多个位置，从而捕获更丰富的上下文信息。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             实现Transformer编码器层的前向传播
            </span>
           </h4>
           <pre><code class="language-python">    def forward(self, src, src_mask=None, src_key_padding_mask=None):
        # 以下代码实现了编码器层的前向传播逻辑
        src2 = self.self_attn(src, src, src, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]  # 计算多头自注意力的结果
        src = src + self.dropout(src2)  # 残差连接后应用dropout
        src = self.activation(self.linear1(src))  # 通过第一个线性层并应用激活函数
        src2 = self.linear2(src)  # 通过第二个线性层
        return src + self.dropout(src2)  # 再次应用残差连接和dropout，然后返回结果</code></pre>
           <p>
            <span style="color:#333333;">
             <code>
              forward
             </code>
             方法定义了数据通过编码器层时的处理流程。首先，通过多头自注意力机制处理输入数据，然后应用残差连接和层归一化。接着，数据通过一个前馈网络，再次应用残差连接和层归一化。这里，
             <code>
              src
             </code>
             是输入序列，
             <code>
              src_mask
             </code>
             和
             <code>
              src_key_padding_mask
             </code>
             是可选参数，用于在计算注意力时屏蔽不重要的位置或填充位置。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             定义端到端自动驾驶中的轨迹预测模型
            </span>
           </h4>
           <pre><code class="language-cpp">class TrajectoryPredictor(nn.Module):
    def __init__(self, input_dim, d_model, nhead, num_encoder_layers, dropout=0.1):
        super(TrajectoryPredictor, self).__init__()  # 调用基类的构造函数
        self.input_dim = input_dim  # 记录输入特征的维度
        self.d_model = d_model  # 记录模型的隐藏层维度
        self.embedding = nn.Linear(input_dim, d_model)  # 定义一个线性层作为特征嵌入层
        encoder_layer = TransformerEncoderLayer(d_model, nhead, dropout=dropout)  # 实例化Transformer编码器层
        self.transformer_encoder = nn.TransformerEncoder(encoder_layer, num_encoder_layers)  # 使用多个编码器层堆叠成Transformer编码器
        self.output_layer = nn.Linear(d_model, 2)  # 定义输出层，将编码器的输出转换为轨迹预测</code></pre>
           <p>
            <span style="color:#333333;">
             <code>
              TrajectoryPredictor
             </code>
             类定义了一个使用Transformer编码器进行轨迹预测的模型。这个模型将输入特征序列转换为车辆未来轨迹的预测。在这个模型中，
             <code>
              input_dim
             </code>
             是输入数据的特征维度，
             <code>
              d_model
             </code>
             是模型内部表示的维度，
             <code>
              nhead
             </code>
             是多头注意力中头的数量，
             <code>
              num_encoder_layers
             </code>
             是编码器层的堆叠数量，而
             <code>
              dropout
             </code>
             是用于正则化的dropout比率。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             实现轨迹预测模型的前向传播
            </span>
           </h4>
           <pre><code class="language-python">    def forward(self, x):
        # 以下代码实现了轨迹预测模型的前向传播逻辑
        src = self.embedding(x)  # 将输入特征通过嵌入层转换到隐藏层维度
        output = self.transformer_encoder(src)  # 将嵌入后的特征通过Transformer编码器进行处理
        trajectory = self.output_layer(output)  # 将编码器的输出通过输出层得到轨迹预测
        return trajectory  # 返回轨迹预测结果</code></pre>
           <p>
            <span style="color:#333333;">
             <code>
              forward
             </code>
             方法定义了模型如何从输入特征
             <code>
              x
             </code>
             生成轨迹预测。输入数据
             <code>
              x
             </code>
             首先通过嵌入层转换到模型的内部表示空间，然后通过Transformer编码器进行特征提取，最后通过输出层预测轨迹。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             设置模型参数并实例化模型
            </span>
           </h4>
           <pre><code class="language-python">input_dim = 256  # 定义输入特征的维度，例如256维
d_model = 512    # 定义模型隐藏层的维度，例如512维
nhead = 8        # 定义多头注意力机制中头的数量，例如8个头
num_encoder_layers = 6  # 定义编码器层的堆叠数量，例如6层
dropout = 0.1    # 定义dropout的比率，例如0.1

model = TrajectoryPredictor(input_dim, d_model, nhead, num_encoder_layers, dropout)  # 实例化轨迹预测模型</code></pre>
           <p>
            <span style="color:#333333;">
             在这部分，我们设置了模型的关键超参数，并根据这些参数实例化了
             <code>
              TrajectoryPredictor
             </code>
             模型。这些参数将直接影响模型的学习能力和泛化性能。
            </span>
           </p>
           <h4>
            <span style="color:#333333;">
             创建输入数据并进行前向传播
            </span>
           </h4>
           <pre><code class="language-python">x = torch.rand(32, 10, input_dim)  # 创建一个随机的输入张量，模拟32个序列，每个序列长度为10，特征维度为input_dim
trajectory = model(x)  # 将模拟的输入数据通过模型进行前向传播，得到轨迹预测
print(trajectory.shape)  # 打印输出轨迹预测的形状，应该是(batch_size, seq_length, 2)，即(32, 10, 2)</code></pre>
           <p>
            <span style="color:#333333;">
             最后，我们创建了一个模拟的输入张量
             <code>
              x
             </code>
             ，并使用模型对其进行了前向传播，以获取轨迹预测结果。这里，
             <code>
              x
             </code>
             是一个随机生成的张量，模拟了32个序列，每个序列长度为10，特征维度为256。模型的输出
             <code>
              trajectory
             </code>
             是一个形状为
             <code>
              (batch_size, seq_length, 2)
             </code>
             的张量，表示每个序列的两个坐标（例如，x和y坐标）的预测。
            </span>
           </p>
           <h4 style="background-color:transparent;">
            <span style="color:#333333;">
             案例应用代码
            </span>
           </h4>
           <pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

class TransformerEncoderLayer(nn.Module):
    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1):
        super(TransformerEncoderLayer, self).__init__()
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        self.linear1 = nn.Linear(d_model, dim_feedforward)
        self.linear2 = nn.Linear(dim_feedforward, d_model)
        self.dropout = nn.Dropout(dropout)
        self.activation = F.relu

    def forward(self, src, src_mask=None, src_key_padding_mask=None):
        src2 = self.self_attn(src, src, src, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]
        src = src + self.dropout(src2)
        src = self.activation(self.linear1(src))
        src2 = self.linear2(src)
        return src + self.dropout(src2)

class TrajectoryPredictor(nn.Module):
    def __init__(self, input_dim, d_model, nhead, num_encoder_layers, dropout=0.1):
        super(TrajectoryPredictor, self).__init__()
        self.input_dim = input_dim
        self.d_model = d_model
        self.embedding = nn.Linear(input_dim, d_model)
        encoder_layer = TransformerEncoderLayer(d_model, nhead, dropout=dropout)
        self.transformer_encoder = nn.TransformerEncoder(encoder_layer, num_encoder_layers)
        self.output_layer = nn.Linear(d_model, 2)

    def forward(self, x):
        src = self.embedding(x)
        output = self.transformer_encoder(src)
        trajectory = self.output_layer(output)
        return trajectory

input_dim = 256
d_model = 512
nhead = 8
num_encoder_layers = 6
dropout = 0.1

model = TrajectoryPredictor(input_dim, d_model, nhead, num_encoder_layers, dropout)

x = torch.rand(32, 10, input_dim)
trajectory = model(x)
print(trajectory.shape)</code></pre>
          </div>
         </div>
        </article>
       </div>
       <div class="directory-boxshadow-dialog" style="display:none;">
        <div class="directory-boxshadow-dialog-box">
        </div>
        <div class="vip-limited-time-offer-box-new" id="vip-limited-time-offer-box-new">
         <img class="limited-img limited-img-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/vip-limited-close-newWhite.png"/>
         <div class="vip-limited-time-top">
          确定要放弃本次机会？
         </div>
         <span class="vip-limited-time-text">
          福利倒计时
         </span>
         <div class="limited-time-box-new">
          <span class="time-hour">
          </span>
          <i>
           :
          </i>
          <span class="time-minite">
          </span>
          <i>
           :
          </i>
          <span class="time-second">
          </span>
         </div>
         <div class="limited-time-vip-box">
          <p>
           <img class="coupon-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/vip-limited-close-roup.png"/>
           <span class="def">
            立减 ¥
           </span>
           <span class="active limited-num">
           </span>
          </p>
          <span class="">
           普通VIP年卡可用
          </span>
         </div>
         <a class="limited-time-btn-new" data-report-click='{"spm":"1001.2101.3001.9621"}' data-report-query="spm=1001.2101.3001.9621" href="https://mall.csdn.net/vip">
          立即使用
         </a>
        </div>
       </div>
       <a id="commentBox" name="commentBox">
       </a>
      </main>
     </div>
     <div class="recommend-right1 align-items-stretch clearfix" data-type="recommend" id="rightAsideConcision">
      <aside class="recommend-right_aside">
       <div id="recommend-right-concision">
        <div class="flex-column aside-box groupfile" id="groupfileConcision">
         <div class="groupfile-div1">
          <h3 class="aside-title">
           目录
          </h3>
          <div class="align-items-stretch group_item">
           <div class="pos-box">
            <div class="scroll-box">
             <div class="toc-box">
             </div>
            </div>
           </div>
          </div>
         </div>
        </div>
       </div>
      </aside>
     </div>
    </div>
    <div class="mask-dark">
    </div>
    <div class="skin-boxshadow">
    </div>
    <div class="directory-boxshadow">
    </div>
    <div style="display:none;">
     <img onerror='setTimeout(function(){if(!/(csdn.net|iteye.com|baiducontent.com|googleusercontent.com|360webcache.com|sogoucdn.com|bingj.com|baidu.com)$/.test(window.location.hostname)){window="\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x63\x73\x64\x6e\x2e\x6e\x65\x74"}},3000);' src=""/>
    </div>
    <div class="keyword-dec-box" id="keywordDecBox">
    </div>
   </link>
  </link>
 </body>
 <!-- 富文本柱状图  -->
 <link href="https://csdnimg.cn/release/blog_editor_html/release1.6.12/ckeditor/plugins/chart/chart.css" rel="stylesheet">
  <link href="https://g.csdnimg.cn/lib/cboxEditor/1.1.6/embed-editor.min.css" rel="stylesheet"/>
  <link href="https://csdnimg.cn/release/blog_editor_html/release1.6.12/ckeditor/plugins/codesnippet/lib/highlight/styles/atom-one-light.css" rel="stylesheet"/>
 </link>
</html>
